/// <reference types="node" />
import { BitstreamElement, BitstreamReader, BitstreamWriter, FieldDefinition, Serializer } from "@astronautlabs/bitstream";
export declare enum TypeMarker {
    Undefined = 0,
    Null = 1,
    False = 2,
    True = 3,
    Integer = 4,
    Double = 5,
    String = 6,
    XmlDocument = 7,
    Date = 8,
    Array = 9,
    Object = 10,
    Xml = 11,
    ByteArray = 12,
    VectorInt = 13,
    VectorUint = 14,
    VectorDouble = 15,
    VectorObject = 16,
    Dictionary = 17
}
export declare const REFERENCE_TYPES: TypeMarker[];
export declare function Type(type: Function): PropertyDecorator;
export declare function amfTypeForProperty(object: any, propertyKey: string): Constructor<Value>;
export declare function amfValueForProperty(object: any, propertyKey: string): Value;
export declare type Constructor<T> = {
    new (): T;
};
export declare function amfTypeForValue(value: any): Constructor<Value>;
export declare class References {
    strings: StringValue[];
    traits: Traits[];
    values: Value[];
}
/**
 * Represents an AMF3 "Value" in the binary protocol
 */
export declare class Value<T = any> extends BitstreamElement {
    get references(): References;
    marker: TypeMarker;
    get value(): T;
    set value(value: T);
    static get undefined(): UndefinedValue;
    static get null(): NullValue;
    static boolean(value: boolean): TrueValue | FalseValue;
    static int(value: number): IntegerValue;
    static double(value: number): DoubleValue;
    static string(value: string): StringValue;
    static xmlDocument(value: string): XmlDocumentValue;
    static xml(value: string): XmlValue;
    static date(value: Date): DateValue;
    static any(value: any): Value;
    static array(array: any[]): ArrayValue;
    static object(value: object): ObjectValueWithLiteralTraits;
    static byteArray(buffer: Uint8Array | Buffer): ByteArray;
    static vector(value: Int32Array | Uint32Array | number[], isFixed?: boolean): UIntVectorValue | IntVectorValue | DoubleVectorValue;
    static objectVector(values: any[], isFixed?: boolean): ObjectVectorValue;
    static dictionary<K, V>(map: Map<K, V>): DictionaryValue<K, V>;
}
export declare class UndefinedValue extends Value<undefined> {
    marker: TypeMarker;
    get value(): any;
}
export declare class NullValue extends Value<null> {
    marker: TypeMarker;
    get value(): any;
}
export declare class FalseValue extends Value<false> {
    marker: TypeMarker;
    get value(): false;
}
export declare class TrueValue extends Value<true> {
    marker: TypeMarker;
    get value(): true;
}
export declare class IntegerValue extends Value<number> {
    marker: TypeMarker;
    $value: number;
    get value(): number;
    set value(value: number);
}
export declare class DoubleValue extends Value<number> {
    marker: TypeMarker;
    $value: number;
    get value(): number;
    set value(value: number);
}
export declare class StringOrReference extends BitstreamElement {
    private $lengthOrReference;
    get isReference(): boolean;
    get isLiteral(): boolean;
    private $value;
    get id(): number;
    set id(value: number);
    get value(): string;
    set value(value: string);
}
export declare class ReferenceValue<T> extends Value<T> {
}
/**
 * Represents the "String" type of "Value" in Adobe's ActionScript Message Format (AMF) version 3.
 * - U29Serializer: Encodes/decodes values in AMF3's custom variable-length integer format
 * - Low bit of 0 or 1 on the "length" field determines if the value is a reference to a String Table entry
 *   or is an inline string literal
 * - Thus IDs and lengths are limited to 2^28 since variable length strs are max 29 bits
 *
 * From the user's perspective, just set either `id` or `value`. When reading use `isReference()` to determine
 * whether this string is a reference to the string table or literal and `id` or `value` respectively. `id` and
 * `value` return `undefined` when they are not relevant for this object.
 */
export declare class StringValue extends ReferenceValue<string> {
    marker: TypeMarker;
    stringOrReference: StringOrReference;
    get isLiteral(): boolean;
    get isReference(): boolean;
    get id(): number;
    set id(id: number);
    get value(): string;
    set value(value: string);
}
export declare class XmlDocumentValue extends StringValue {
    marker: TypeMarker;
}
export declare class XmlValue extends StringValue {
    marker: TypeMarker;
}
export declare class DateValue extends ReferenceValue<Date> {
    marker: TypeMarker;
    $indicator: number;
    get isLiteral(): boolean;
    get isReference(): boolean;
    private $value;
    private $date;
    get value(): Date;
    set value(value: Date);
}
export declare class AssociativeValueSerializer implements Serializer {
    read(reader: BitstreamReader, type: any, parent: BitstreamElement, field: FieldDefinition): Generator<{
        remaining: number;
        contextHint: () => string;
    }, AssociativeValue[], unknown>;
    write(writer: BitstreamWriter, type: any, parent: BitstreamElement, field: FieldDefinition, value: AssociativeValue[]): void;
}
export declare class AssociativeValue extends BitstreamElement {
    private $key;
    get key(): string;
    set key(value: string);
    value: Value;
}
export declare class ArrayValue<T = any> extends ReferenceValue<T[]> {
    marker: TypeMarker;
    private $denseLengthOrReference;
    get isReference(): boolean;
    get isLiteral(): boolean;
    get id(): number;
    set id(value: number);
    get denseLength(): number;
    associativeValues: AssociativeValue[];
    private $values;
    get values(): Value<any>[];
    set values(value: Value<any>[]);
}
export declare class ClassRegistry {
    private _map;
    register(klass: Function, name?: string): void;
    get(name: string): Function;
}
export declare class ObjectValue extends ReferenceValue<object> {
    get registry(): ClassRegistry;
    marker: TypeMarker;
    $objectTypeIndicator: number;
    get isReference(): boolean;
    get isLiteral(): boolean;
    get isTraitLiteral(): boolean;
    get isTraitReference(): boolean;
    get isExternalizable(): boolean;
    get id(): number;
    set id(value: number);
    static reference(id: number): ObjectValue;
    $variantMarker: any;
    private _dynamicMembers;
    get dynamicMembers(): AssociativeValue[];
    set dynamicMembers(value: AssociativeValue[]);
    private _values;
    get values(): Value<any>[];
    set values(value: Value<any>[]);
}
export declare class Traits extends BitstreamElement {
    className: StringOrReference;
    sealedMemberNames: StringOrReference[];
    get isDynamic(): boolean;
}
export declare class ObjectValueWithInternalTraits extends ObjectValue {
    $objectTypeIndicator: number;
    get traits(): Traits;
    private _value;
    get value(): object;
    set value(value: object);
    get values(): Value<any>[];
    set values(value: Value<any>[]);
    set dynamicMembers(value: AssociativeValue[]);
    protected buildValue(): void;
    onParseFinished(): void;
}
export declare class ObjectValueWithLiteralTraits extends ObjectValueWithInternalTraits {
    $objectTypeIndicator: number;
    get isDynamic(): boolean;
    set isDynamic(value: boolean);
    get sealedMemberNameCount(): number;
    set sealedMemberNameCount(value: number);
    private $traits;
    get traits(): Traits;
    set traits(value: Traits);
    get value(): object;
    set value(value: object);
}
export declare class ObjectValueWithReferencedTraits extends ObjectValueWithInternalTraits {
    $objectTypeIndicator: number;
    get traitsId(): number;
    set traitsId(id: number);
    get traits(): Traits;
    set traits(value: Traits);
}
export declare class ObjectValueWithExternalizableTraits extends ObjectValue {
    $objectTypeIndicator: number;
    className: StringOrReference;
}
export declare class ObjectValueWithUnknownExternalizableTraits extends ObjectValueWithExternalizableTraits {
    constructor();
}
export declare class ByteArray extends ReferenceValue<Buffer> {
    marker: TypeMarker;
    private $lengthOrReference;
    get isReference(): boolean;
    get isLiteral(): boolean;
    get id(): number;
    set id(value: number);
    $value: Buffer;
    get value(): Buffer;
    set value(value: Buffer);
}
export declare class VectorValue<T = any> extends ReferenceValue<T> {
    protected $lengthOrReference: number;
    get isReference(): boolean;
    get isLiteral(): boolean;
    get id(): number;
    set id(value: number);
    get length(): number;
    isFixed: boolean;
}
export declare class ObjectVectorValue extends VectorValue<object> {
    marker: TypeMarker;
    values: Value[];
    get value(): Value<any>[];
    set value(value: Value<any>[]);
    objectTypeName: StringOrReference;
}
export declare class DoubleVectorValue extends VectorValue<number[]> {
    marker: TypeMarker;
    values: number[];
    get value(): number[];
    set value(value: number[]);
}
export declare class IntVectorValue extends VectorValue<Int32Array> {
    marker: TypeMarker;
    private _bytes;
    private _elements;
    get bytes(): Uint8Array;
    set bytes(value: Uint8Array);
    get value(): Int32Array;
    set value(value: Int32Array);
}
export declare class UIntVectorValue extends VectorValue<Uint32Array> {
    marker: TypeMarker;
    private _bytes;
    private _elements;
    get bytes(): Uint8Array;
    set bytes(value: Uint8Array);
    get value(): Uint32Array;
    set value(value: Uint32Array);
}
export declare class DictionaryEntry extends BitstreamElement {
    key: Value;
    value: Value;
}
export declare class DictionaryValue<K = any, V = any> extends ReferenceValue<Map<K, V>> {
    marker: TypeMarker;
    private $lengthOrReference;
    get isReference(): boolean;
    get isLiteral(): boolean;
    get id(): number;
    set id(value: number);
    get length(): number;
    hasWeakKeys: boolean;
    get value(): Map<K, V>;
    set value(value: Map<K, V>);
    private $entries;
    get entries(): DictionaryEntry[];
    set entries(value: DictionaryEntry[]);
}
