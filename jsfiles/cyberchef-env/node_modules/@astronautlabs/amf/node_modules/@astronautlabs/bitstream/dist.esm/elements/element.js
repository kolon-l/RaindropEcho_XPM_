var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _BitstreamElement_parent, _BitstreamElement_readFields, _BitstreamElement_isBeingRead, _BitstreamElement_fieldBeingComputed, _BitstreamElement_fieldBeingComputedIntrospectable;
import { BitstreamMeasurer, BitstreamReader, BitstreamWriter } from "../bitstream";
import { BufferedWritable } from "../common";
const SERIALIZE_WRITERS = Symbol('Writers used by Bitstream#serialize() for this element type.');
/**
 * BitstreamElement is a base class which can be extended to produce "structures" that can be
 * read from and written to a bitstream. It allows you to specify fields along with their type
 * and bitlength information declaratively, allowing BitstreamElement itself to handle the actual
 * serialization/deserialization in the context of a passed BitstreamReader/BitstreamWriter.
 */
export class BitstreamElement {
    constructor() {
        /**
         * The size of the write buffer when using the serialize() method. This is set to 1KB by default, but may need to
         * be tweaked for large objects.
         */
        this.serializeBufferSize = 1024;
        _BitstreamElement_parent.set(this, void 0);
        _BitstreamElement_readFields.set(this, []);
        _BitstreamElement_isBeingRead.set(this, void 0);
        _BitstreamElement_fieldBeingComputed.set(this, void 0);
        _BitstreamElement_fieldBeingComputedIntrospectable.set(this, void 0);
    }
    // Lifecycle events
    /**
     * Called when this object is created as part of an element parsing operation.
     * - For unvariated elements this is called before parsing begins.
     * - For variated elements this is called before the original element's fields are copied into this instance.
     *   The instance being variated is passed as 'variatingFrom' in this case.
     *
     * In either case, no fields have been populated within the instance before the lifecycle event is invoked.
     * To observe the values copied in when this object is the result of variation, see onVariationFrom().
     */
    onParseStarted(variatingFrom) { }
    /**
     * Called when this object has completed parsing including all variation operations.
     *
     * Note that onParseFinished() may not be invoked if the bitstream is exhausted before
     * parsing is finished or if this instance is replaced via variation. To observe this process, use
     * onVariationTo/onVariationFrom. The final variation is the only one that has onParseFinished() invoked.
     */
    onParseFinished() { }
    /**
     * Called when this object is undergoing variation. The 'replacement' parameter contains the newly variated
     * object. No further lifecycle events will occur for this instance, and all future lifecycle events occur on
     * the replacement object.
     *
     * @param replacement
     */
    onVariationTo(replacement) { }
    /**
     * Called when this object is the result of a variation operation. The 'source' parameter contains the original
     * object. At this point all fields of the variation source have been copied into the new variant object.
     * @param source
     */
    onVariationFrom(source) { }
    /**
     * Called when this object is about to be serialized to a BitstreamWriter.
     */
    onSerializeStarted() { }
    /**
     * Called when this object has been completely serialized to a BitstreamWriter.
     */
    onSerializeFinished() { }
    /**
     * Retrieve the "syntax" of this element, which is the list of fields defined on the element
     * in order of appearance within the bitstream.
     */
    static get syntax() {
        let parentSyntax = (Object.getPrototypeOf(this).syntax || []);
        let syntax = parentSyntax.slice();
        let ownSyntax = this.ownSyntax;
        let insertIndex = syntax.findIndex(x => x.options.isVariantMarker);
        if (insertIndex >= 0)
            syntax.splice(insertIndex, 0, ...ownSyntax);
        else
            syntax.push(...ownSyntax);
        return syntax;
    }
    determineVariantType(parent, variants) {
        var _a;
        let elementType = this.constructor;
        variants !== null && variants !== void 0 ? variants : (variants = elementType['variants'] || []);
        let variantDefns = variants.map((typeOrVariant) => typeof typeOrVariant === 'function'
            ? { type: typeOrVariant, discriminant: typeOrVariant.variantDiscriminant }
            : typeOrVariant);
        variantDefns = variantDefns.sort((a, b) => {
            let aPriority = a.options.priority || 0;
            let bPriority = b.options.priority || 0;
            if (aPriority === 'first')
                aPriority = Number.MIN_SAFE_INTEGER;
            if (aPriority === 'last')
                aPriority = Number.MAX_SAFE_INTEGER;
            if (bPriority === 'first')
                bPriority = Number.MIN_SAFE_INTEGER;
            if (bPriority === 'last')
                bPriority = Number.MAX_SAFE_INTEGER;
            return aPriority - bPriority;
        });
        return (_a = variantDefns.find(v => v.discriminant(this, parent))) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Create a copy of this element instance
     * @returns A new copy of this element
     */
    clone() {
        let newInstance = new this.constructor();
        for (let field of this.syntax)
            newInstance[field.name] = this[field.name];
        return newInstance;
    }
    /**
     * Retrieve the field definition of a field as specified by the given field reference
     * @param ref The field being referenced
     * @returns The field definition
     */
    selectField(ref) {
        if (typeof ref === 'string' || typeof ref === 'symbol')
            return this.syntax.find(x => x.name === ref);
        let selector = this.syntax.reduce((pv, cv) => (pv[cv.name] = cv.name, pv), {});
        let selected = ref(selector);
        return this.syntax.find(x => x.name === selected);
    }
    /**
     * Serialize all fields or a subset of fields into a buffer.
     * @param fromRef The first field that should be serialized. If not specified, serialization begins at the start of
     *                  the element
     * @param toRef The last field that should be serialized. If not specified, serialization continues until the end of
     *                  the element
     * @param autoPad When true and the bitsize of a field is not a multiple of 8, the final byte will
     *                  contain zeros up to the next byte. When false (default), serialize() will throw
     *                  if the size is not a multiple of 8.
     */
    serialize(fromRef, toRef, autoPad = false) {
        var _a;
        if (this.syntax.length === 0)
            return;
        if (!fromRef)
            fromRef = this.syntax[0].name;
        if (!toRef) {
            if (this.getFieldBeingComputed()) {
                let toIndex = this.syntax.findIndex(f => f.name === this.getFieldBeingComputed().name);
                if (!this.getFieldBeingComputedIntrospectable())
                    toIndex -= 1;
                if (toIndex < 0)
                    return new Uint8Array(0);
                toRef = this.syntax[toIndex].name;
            }
            else if (this.isBeingRead) {
                let readFields = this.syntax.filter(x => this.readFields.includes(x.name)).map(x => x.name);
                toRef = readFields[readFields.length - 1];
            }
            else {
                toRef = this.syntax[this.syntax.length - 1].name;
            }
        }
        this.context = {};
        let from = this.selectField(fromRef);
        let to = this.selectField(toRef);
        let fromIndex = this.syntax.findIndex(x => x === from);
        let toIndex = this.syntax.findIndex(x => x === to);
        let stream = new BufferedWritable();
        // To reduce allocations during serialize(), we need to reuse writers.
        if (!this.constructor[SERIALIZE_WRITERS])
            this.constructor[SERIALIZE_WRITERS] = [];
        let writer = (_a = this.constructor[SERIALIZE_WRITERS].pop()) !== null && _a !== void 0 ? _a : new BitstreamWriter(stream, this.serializeBufferSize);
        writer.stream = stream;
        try {
            if (fromIndex > toIndex) {
                throw new Error(`Cannot measure from field ${fromIndex} (${String(from.name)}) to ${toIndex} (${String(to.name)}): First field comes after last field`);
            }
            for (let i = fromIndex, max = toIndex; i <= max; ++i) {
                let field = this.syntax[i];
                if (!this.isPresent(field, this))
                    continue;
                let writtenValue = this[field.name];
                if (field.options.writtenValue) {
                    if (typeof field.options.writtenValue === 'function') {
                        writtenValue = field.options.writtenValue(this, field);
                    }
                    else {
                        writtenValue = field.options.writtenValue;
                    }
                }
                try {
                    field.options.serializer.write(writer, field.type, this, field, writtenValue);
                }
                catch (e) {
                    if (globalThis.BITSTREAM_TRACE !== false) {
                        console.error(`Failed to write field ${field.type.name}#${String(field.name)} using ${field.options.serializer.constructor.name}: ${e.message}`);
                        console.error(e);
                    }
                    throw new Error(`Failed to write field ${String(field.name)} using ${field.options.serializer.constructor.name}: ${e.message}`);
                }
            }
            if (writer.byteOffset !== 0 && !autoPad) {
                let length = writer.offset;
                throw new Error(`${length} bits (${Math.floor(length / 8)} bytes + ${length % 8} bits) is not an even amount of bytes!`);
            }
            writer.end();
            return stream.buffer;
        }
        finally {
            writer.reset();
            this.constructor[SERIALIZE_WRITERS].push(writer);
        }
    }
    /**
     * Measure the number of bits starting from the first field and continuing through the structure until the last
     * field.
     * @param fromRef The field to start measuring from (including the specified field). When not specified, measurement
     *                  starts from the first field
     * @param toRef The field to stop measuring at (including the specified field). When not specified, measurement
     *                  ends at the last field
     * @returns The number of bits occupied by the range of fields
     */
    measure(fromRef, toRef) {
        if (!fromRef)
            fromRef = this.syntax[0].name;
        if (!toRef) {
            if (this.getFieldBeingComputed()) {
                let toIndex = this.syntax.findIndex(f => f.name === this.getFieldBeingComputed().name);
                if (!this.getFieldBeingComputedIntrospectable())
                    toIndex -= 1;
                if (toIndex < 0)
                    return 0;
                toRef = this.syntax[toIndex].name;
            }
            else if (this.isBeingRead) {
                let readFields = this.syntax.filter(x => this.readFields.includes(x.name)).map(x => x.name);
                toRef = readFields[readFields.length - 1];
            }
            else {
                toRef = this.syntax[this.syntax.length - 1].name;
            }
        }
        let from = this.selectField(fromRef);
        let to = this.selectField(toRef);
        let fieldBeingRead = this.syntax.find(x => !this.readFields.includes(x.name));
        let fromIndex = this.syntax.findIndex(x => x === from);
        let toIndex = this.syntax.findIndex(x => x === to);
        let measurer = new BitstreamMeasurer();
        if (fromIndex > toIndex) {
            throw new Error(`Cannot measure from field ${fromIndex} (${String(from.name)}) to ${toIndex} (${String(to.name)}): First field comes after last field`);
        }
        for (let i = fromIndex, max = toIndex; i <= max; ++i) {
            let field = this.syntax[i];
            if (!this.isPresent(field, this))
                continue;
            try {
                field.options.serializer.write(measurer, this.constructor, this, field, this[field.name]);
            }
            catch (e) {
                if (globalThis.BITSTREAM_TRACE === true) {
                    console.error(`Failed to measure field ${this.constructor.name}#${String(field.name)}:`);
                    console.error(e);
                }
                throw new Error(`${this.constructor.name}#${String(field.name)}: Cannot measure field: ${e.message}`);
            }
        }
        return measurer.bitLength;
    }
    /**
     * Measure from the beginning of the element to the given field
     * @param toRef The field to stop measuring at (including the specified field)
     * @returns The number of bits occupied by the set of fields
     */
    measureTo(toRef) {
        return this.measure(undefined, toRef);
    }
    /**
     * Measure from the given field to the end of the element
     * @param fromRef The field to start measuing at (including the specified field)
     * @returns The number of bits occupied by the set of fields
     */
    measureFrom(fromRef) {
        return this.measure(fromRef, undefined);
    }
    /**
     * Measure the size of a specific field
     * @param ref The field to measure
     * @returns The number of bits occupied by the field
     */
    measureField(ref) {
        return this.measure(ref, ref);
    }
    /**
     * Check that this instance is one of a set of given subtypes. If it is,
     * this instance is returned with the more specific type.
     * If it is not, an error is thrown.
     *
     * @param typeChecks One or more subclasses to check
     * @returns This instance, but casted to the desired type
     */
    as(...typeChecks) {
        if (!typeChecks.some(x => this instanceof x))
            throw new Error(`Tried to cast to one of [${typeChecks.map(x => x.name).join(', ')}], but ${this.constructor.name} does not inherit from any of them`);
        return this;
    }
    /**
     * Check that this instance is one of a set of given subtypes.
     * @param typeChecks
     * @returns
     */
    is(...typeChecks) {
        return typeChecks.some(x => this instanceof x);
    }
    /**
     * Retrieve the set of defined variants for this element class
     */
    static get variants() {
        return this.hasOwnProperty('ownVariants') ? this.ownVariants : [];
    }
    /**
     * Retrieve the syntax defined for this specific class, excluding the syntax
     * defined by its superclasses
     */
    static get ownSyntax() {
        let obj = this;
        if (!obj.hasOwnProperty('$ownSyntax')) {
            Object.defineProperty(obj, '$ownSyntax', {
                writable: true,
                value: [],
                enumerable: false
            });
        }
        return obj['$ownSyntax'];
    }
    static set ownSyntax(value) {
        this.ownSyntax.length; // causes property to be created
        this['$ownSyntax'] = value;
    }
    /**
     * Retrieve the element which contains this element, if any
     */
    get parent() {
        return __classPrivateFieldGet(this, _BitstreamElement_parent, "f");
    }
    /**
     * Set the parent element of this element
     */
    set parent(value) {
        __classPrivateFieldSet(this, _BitstreamElement_parent, value, "f");
    }
    /**
     * True when this element is currently being read, false otherwise
     */
    get isBeingRead() {
        return __classPrivateFieldGet(this, _BitstreamElement_isBeingRead, "f");
    }
    /**
     * Set whether this element is currently being read
     */
    set isBeingRead(value) {
        __classPrivateFieldSet(this, _BitstreamElement_isBeingRead, value, "f");
    }
    /**
     * Retrieve the set of field names which has been read so far
     */
    get readFields() {
        return __classPrivateFieldGet(this, _BitstreamElement_readFields, "f");
    }
    /**
     * Determine if the field currently being computed is introspectable,
     * meaning that the bits it has read so far will be considered during measurement,
     * even though it possibly has not finished reading all bits it will read yet
     * @returns
     */
    getFieldBeingComputedIntrospectable() {
        return __classPrivateFieldGet(this, _BitstreamElement_fieldBeingComputedIntrospectable, "f");
    }
    /**
     * Get the definition of the field currently being computed, if any.
     * @returns
     */
    getFieldBeingComputed() {
        return __classPrivateFieldGet(this, _BitstreamElement_fieldBeingComputed, "f");
    }
    /**
     * Convert this element to a JSON-compatible representation which contains
     * only the fields defined on the element (aka its "syntax")
     */
    toJSON() {
        return this.syntax
            .map(s => [s.name, this[s.name]])
            .reduce((pv, [k, v]) => (pv[k] = v, pv), {});
    }
    /**
     * Run the given callback while in a state where the given field is considered to be the one "being computed",
     * which is primarily used to enable the current size of arrays as they are read in cases where the count of
     * items in the array is dependent on the overall bitlength of the previous elements that have been read. See
     * the `hasMore` option of ArrayOptions
     *
     * @param field The field being computed
     * @param callback The function to run
     * @param introspectable When true, the computed field is marked as introspectable
     */
    runWithFieldBeingComputed(field, callback, introspectable) {
        let before = this.getFieldBeingComputed();
        let beforeIntrospectable = this.getFieldBeingComputedIntrospectable();
        try {
            __classPrivateFieldSet(this, _BitstreamElement_fieldBeingComputed, field, "f");
            __classPrivateFieldSet(this, _BitstreamElement_fieldBeingComputedIntrospectable, introspectable, "f");
            return callback();
        }
        finally {
            __classPrivateFieldSet(this, _BitstreamElement_fieldBeingComputed, before, "f");
            __classPrivateFieldSet(this, _BitstreamElement_fieldBeingComputedIntrospectable, beforeIntrospectable, "f");
        }
    }
    /**
     * Get the "syntax" of this element instance; this is the set of fields that compose the element, in order.
     */
    get syntax() {
        return this.constructor.syntax;
    }
    /**
     * Get the "syntax" of this element instance excluding syntax defined by its superclasses; this is the
     * set of fields that compose the elemnet, in order.
     */
    get ownSyntax() {
        return this.constructor.ownSyntax;
    }
    leftPad(num, digits = 4) {
        let str = `${num}`;
        while (str.length < digits)
            str = ` ${str}`;
        return str;
    }
    rightPad(num, digits = 4) {
        let str = `${num}`;
        while (str.length < digits)
            str = `${str} `;
        return str;
    }
    zeroPad(num, digits = 4) {
        let str = `${num}`;
        while (str.length < digits)
            str = `0${str}`;
        return str;
    }
    isPresent(element, instance, reader) {
        var _a, _b;
        if (element.options.presentWhen) {
            if (!instance.runWithFieldBeingComputed(element, () => element.options.presentWhen(instance))) {
                return false;
            }
        }
        if (element.options.excludedWhen) {
            if (instance.runWithFieldBeingComputed(element, () => element.options.excludedWhen(instance))) {
                return false;
            }
        }
        // Perform readahead checks. It is expected that the caller has already read the requisite number of bits 
        // ahead to allow the checks to occur.
        if (reader) {
            if ((_a = element.options.readAhead) === null || _a === void 0 ? void 0 : _a.presentWhen) {
                if (!reader.simulateSync(() => element.options.readAhead.presentWhen(reader, instance)))
                    return false;
            }
            if ((_b = element.options.readAhead) === null || _b === void 0 ? void 0 : _b.excludedWhen) {
                if (reader.simulateSync(() => element.options.readAhead.excludedWhen(reader, instance)))
                    return false;
            }
        }
        return true;
    }
    /**
     * Read a specific group of fields from the bitstream and serialize their values into this instance. This is called
     * by BitstreamElement for you, but can be used when overriding the default read behavior.
     * @param bitstream The bitstream reader to read from
     * @param name The name of the group to read. Some special values are accepted: '*' means all fields, '$*' means all
     *              fields defined directly on this class (excluding its superclasses). Other group specifiers starting
     *              with '$' match fields defined directly on this class which are part of the specified group (for
     *              instance '$foo' matches directly defined fields in the 'foo' group). Otherwise, the string is
     *              matched directly against the 'group' option of all fields.
     * @param variator A function which implements variation of this instance in the case where a `@VariantMarker` is
     *              encountered. The function should determine an appropriate variant and return it; when it does so,
     *              the group will continue to be read after the marker, but the results of reading the field will be
     *              applied to the returned instance instead of this instance
     * @param options Serialization options that modify how the group is read. Most notably this allows you to skip
     *              specific fields.
     * @returns A generator. When the read is complete (done=true), the result will be the current instance,
     *              unless the instance was variated into a subclass, in which case it will be the
     *              variated subclass instance. Because this process can occur, it is important to observe the result
     *              of this function. If the read buffer becomes exhausted, an IncompleteReadResult will be returned.
     */
    *readGroup(bitstream, name, options) {
        let wasBeingRead = this.isBeingRead;
        let instance = this;
        instance.isBeingRead = true;
        try {
            let syntax;
            if (name === '*') { // all my fields
                syntax = this.syntax;
            }
            else if (name === '$*') { // all my own fields
                syntax = this.ownSyntax;
            }
            else if (name.startsWith('$')) { // my own fields in group $<group>
                // if (name !== '*' && element.options.group !== name)
                let group = name.slice(1);
                syntax = this.ownSyntax.filter(x => x.options.group === group);
            }
            else { // all my fields in group <group>
                syntax = this.ownSyntax.filter(x => x.options.group === name);
            }
            for (let element of syntax) {
                // Preconditions 
                if (element.options.readAhead) {
                    let length = 0;
                    if (typeof element.options.readAhead.length === 'number') {
                        length = element.options.readAhead.length;
                    }
                    else if (typeof element.options.readAhead.length === 'function') {
                        length = element.options.readAhead.length(instance, element);
                    }
                    if (bitstream.available < length) {
                        yield {
                            remaining: length - bitstream.available,
                            contextHint: () => `[readAhead ${length} bits]`,
                            optional: true
                        };
                    }
                }
                if (!this.isPresent(element, instance, bitstream))
                    continue;
                if ((options === null || options === void 0 ? void 0 : options.skip) && options.skip.includes(element.name))
                    continue;
                // If this is a @VariantMarker(), perform marker variation.
                // This is one of two ways variation can occur- the other being 
                // "tail variation" which happens after all fields of this type are parsed
                // and none of them are marked with @VariantMarker().
                if (element.options.isVariantMarker) {
                    if (globalThis.BITSTREAM_TRACE)
                        console.log(`Variating at marker...`);
                    let g = this.variate(bitstream, options.parent, options.field);
                    while (true) {
                        let result = g.next();
                        if (result.done === false) {
                            let incompleteResult = result.value;
                            yield {
                                remaining: incompleteResult.remaining,
                                contextHint: () => this.summarizeElementField(element, incompleteResult.contextHint()),
                                optional: incompleteResult.optional
                            };
                        }
                        else {
                            instance = result.value;
                            break;
                        }
                    }
                    if (!instance)
                        throw new Error(`Variator did not return a value!`);
                    continue;
                }
                // Parsing 
                let traceTimeout;
                if (globalThis.BITSTREAM_TRACE === true) {
                    traceTimeout = setTimeout(() => {
                        console.log(`[!!] ${element.containingType.name}#${String(element.name)}: Stuck reading!`);
                    }, 5000);
                }
                try {
                    let startOffset = bitstream.offset;
                    let g = element.options.serializer.read(bitstream, element.type, instance, element);
                    let readValue;
                    while (true) {
                        let result = g.next();
                        if (result.done === false) {
                            let incompleteResult = result.value;
                            yield {
                                remaining: incompleteResult.remaining,
                                contextHint: () => this.summarizeElementField(element, incompleteResult.contextHint()),
                                optional: incompleteResult.optional,
                            };
                        }
                        else {
                            readValue = result.value;
                            break;
                        }
                    }
                    if (!element.options.isIgnored)
                        instance[element.name] = readValue;
                    instance.readFields.push(element.name);
                    instance.bitsRead += (bitstream.offset - startOffset);
                    let displayedValue = `${readValue}`;
                    if (typeof readValue === 'number') {
                        displayedValue = `0x${readValue.toString(16)} [${readValue}]`;
                    }
                    if (globalThis.BITSTREAM_TRACE === true) {
                        try {
                            console.log(`[ + ${this.leftPad(instance.measureField(element.name), 4)} bit(s) = ${this.leftPad(Math.floor(instance.measureTo(element.name) / 8), 4)} byte(s), ${this.leftPad(instance.measureTo(element.name)
                                - Math.floor(instance.measureTo(element.name) / 8) * 8, 4)} bits = ${this.leftPad(instance.measureTo(element.name), 4)} bits total] `
                                +
                                    `   ${this.rightPad(`${element.containingType.name}#${String(element.name)}`, 50)} <= ${displayedValue}`);
                        }
                        catch (e) {
                            console.log(`Error while tracing read operation for element ${String(element.name)}: ${e.message}`);
                            console.error(e);
                        }
                        clearTimeout(traceTimeout);
                    }
                }
                catch (thrown) {
                    let e = thrown;
                    if (e.message.startsWith('underrun:')) {
                        throw new Error(`Ran out of bits while deserializing field ${String(element.name)} `
                            + `in group '${name}' `
                            + `of element ${instance.constructor.name}`);
                    }
                    else {
                        throw e;
                    }
                }
            }
        }
        finally {
            this.isBeingRead = wasBeingRead;
        }
        return instance;
    }
    /**
     * Write a group of fields to the given bitstream writer. This is used by BitstreamElement internally, but it can
     * be called directly when overriding the default write behavior in a subclass, if desired.
     * @param bitstream The bitstream writer to write the fields to
     * @param name The name of the group to write.
     * @param options Options that modify how the group is written. Most notably this allows you to skip specific
     *                  fields.
     */
    writeGroup(bitstream, name, options) {
        let syntax = this.syntax;
        for (let element of syntax) {
            if (name !== '*' && element.options.group !== name)
                continue;
            if ((options === null || options === void 0 ? void 0 : options.skip) && options.skip.includes(element.name))
                continue;
            // Preconditions 
            if (!this.isPresent(element, this))
                continue;
            let writtenValue = this[element.name];
            if (element.options.writtenValue) {
                if (typeof element.options.writtenValue === 'function') {
                    writtenValue = element.options.writtenValue(this, element);
                }
                else {
                    writtenValue = element.options.writtenValue;
                }
            }
            if (globalThis.BITSTREAM_TRACE === true && !(bitstream instanceof BitstreamMeasurer)) {
                let displayedValue = `${writtenValue}`;
                if (typeof writtenValue === 'number') {
                    displayedValue = `0x${writtenValue.toString(16)} [${writtenValue}]`;
                }
                try {
                    console.log(`[ + ${this.leftPad(this.measureField(element.name), 4)} bit(s) = ${this.leftPad(Math.floor(this.measureTo(element.name) / 8), 4)} byte(s), ${this.leftPad(this.measureTo(element.name)
                        - Math.floor(this.measureTo(element.name) / 8) * 8, 4)} bits = ${this.leftPad(this.measureTo(element.name), 4)} bits total] `
                        +
                            `   ${this.rightPad(`${element.containingType.name}#${String(element.name)}`, 50)} => ${displayedValue}`);
                }
                catch (e) {
                    console.log(`Error while tracing write operation for element ${String(element.name)}: ${e.message}`);
                    console.error(e);
                }
            }
            try {
                element.options.serializer.write(bitstream, element.type, this, element, writtenValue);
            }
            catch (e) {
                if (globalThis.BITSTREAM_TRACE !== false) {
                    console.error(`Failed to write field ${element.type.name}#${String(element.name)} using ${element.options.serializer.constructor.name}: ${e.message}`);
                    console.error(e);
                }
                throw new Error(`Failed to write field ${String(element.name)} using ${element.options.serializer.constructor.name}: ${e.message}`);
            }
        }
    }
    /**
     * Read this element from the given bitstream reader, applying the resulting values into this instance.
     * @param bitstream The reader to read from
     * @param variator A function which implements variation for this instance. The function should determine an
     *                  appropriate variant instance and return it; from there on out the rest of the fields read will
     *                  be applied to that instance instead of this instance.
     * @param options Options which modify how the element is read. Most notably this lets you skip specific fields
     * @returns The current instance, unless it was variated into a subclass instance, in which case it will be the
     *                  variated subclass instance. Thus it is important to observe the result of this method.
     */
    *read(bitstream, options) {
        let g = this.readGroup(bitstream, '*', options);
        while (true) {
            let result = g.next();
            if (result.done === false) {
                let incompleteResult = result.value;
                yield {
                    remaining: incompleteResult.remaining,
                    contextHint: () => this.summarizeElementOperation(`read()`, incompleteResult.contextHint()),
                    optional: incompleteResult.optional,
                };
            }
            else {
                return result.value;
            }
        }
    }
    /**
     * Read just the fields that are part of this specific subclass, ignoring the fields that are defined on superclasses.
     * This is used by BitstreamElement during variation, and is equivalent to readGroup(bitstream, '$*', variator, options)
     * @param bitstream The reader to read from
     * @param variator A function which implements variation for this instance. The function should determine an
     *                  appropriate variant instance and return it; from there on out the rest of the fields read will
     *                  be applied to that instance instead of this instance.
     * @param options Options which modify how the element is read. Most notably this lets you skip specific fields
     * @returns A generator which will yield only one result. If the generator completes (done=true), then the result
     *          will be `this` the current instance, unless it was variated into a subclass instance, in which case
     *          it will be the variated subclass instance. Thus it is important to observe the result of this method.
     *          If the read buffer becomes exhausted, the result will be an IncompleteReadResult.
     */
    *readOwn(bitstream, options) {
        let g = this.readGroup(bitstream, '$*', options);
        while (true) {
            let result = g.next();
            if (result.done === false) {
                let incompleteResult = result.value;
                yield {
                    remaining: incompleteResult.remaining,
                    contextHint: () => this.summarizeElementOperation(`readOwn()`, incompleteResult.contextHint()),
                    optional: incompleteResult.optional
                };
            }
            else {
                return result.value;
            }
        }
    }
    /**
     * Apply variation rules to this element. If one is found, the new variated instance is returned, otherwise
     * the current instance is returned.
     *
     * @param reader The reader to read from
     * @param parent The parent element of this element
     * @param field The Bitstream field that this element is being parsed for when this is a subelement of a larger
     *     parse operation.
     * @returns
     */
    *variate(reader, parent, field) {
        let variantType = this.determineVariantType(parent, field === null || field === void 0 ? void 0 : field.options.variants);
        if (variantType) {
            if (globalThis.BITSTREAM_TRACE)
                console.log(`Selected variant ${variantType.name}`);
            let g = variantType.read(reader, {
                parent, field,
                elementBeingVariated: this,
                context: this.context
            });
            do {
                let result = g.next();
                if (result.done === false) {
                    let incompleteResult = result.value;
                    yield {
                        remaining: incompleteResult.remaining,
                        contextHint: () => this.summarizeElementOperation(`variate()`, incompleteResult.contextHint()),
                        optional: incompleteResult.optional
                    };
                }
                else {
                    return result.value;
                }
            } while (true);
        }
        return this;
    }
    /**
     * Create a new instance of this BitstreamElement subclass by reading the necessary fields from the given
     * BitstreamReader.
     * @param this
     * @param reader The reader to read from
     * @param parent Specify a parent instance which the new instance is found within
     * @returns
     */
    static readBlocking(reader, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let iterator = this.read(reader, options);
            do {
                let result = iterator.next();
                if (result.done === false) {
                    yield reader.assure(result.value.remaining, result.value.optional);
                    continue;
                }
                return result.value;
            } while (true);
        });
    }
    /**
     * Deserialize an instance of this class from the given
     * data buffer. Will consider available variants, so the
     * result could be a subclass.
     * @param data
     * @returns
     */
    static deserialize(data, options = {}) {
        let reader = new BitstreamReader();
        reader.addBuffer(data);
        let gen = this.read(reader, options);
        while (true) {
            let result = gen.next();
            if (result.done === false) {
                throw new Error(`Buffer exhausted while reading ${result.value.remaining} bits `
                    + `at offset ${reader.offset}, `
                    + `context:\n     - ${result.value.contextHint().replace(/\n/g, "\n     - ")}\n\n`);
            }
            else {
                return result.value;
            }
        }
    }
    /**
     * Write this instance to the given writer
     * @param bitstream The writer to write to
     * @param options Options which modify how the element is written. Most notably this lets you skip specific fields
     */
    write(bitstream, options) {
        var _a;
        this.context = (_a = options === null || options === void 0 ? void 0 : options.context) !== null && _a !== void 0 ? _a : {};
        this.onSerializeStarted();
        this.writeGroup(bitstream, '*', options);
        this.onSerializeFinished();
    }
    /**
     * Apply the given properties to this object and return ourself.
     * @param this
     * @param changes The changes to apply
     */
    with(changes) {
        Object.assign(this, changes);
        return this;
    }
    /**
     * Perform a synchronous read operation on the given reader with the given generator. If there are not enough bits available
     * to complete the operation, this method will throw an exception.
     *
     * @param reader
     * @param generator
     * @returns
     */
    static readSync(reader, options = {}) {
        let iterator = this.read(reader, options);
        do {
            let result = iterator.next();
            if (result.done === false) {
                if (reader.ended && result.value.optional)
                    continue;
                throw new Error(`Not enough bits: Reached end of buffer while trying to read ${result.value.remaining} bits! Context: ${result.value.contextHint()}`);
            }
            return result.value;
        } while (true);
    }
    /**
     * Try to read the bitstream using the given generator function synchronously, if there are not enough bits, abort
     * and return undefined.
     * @param reader The reader to read from
     * @returns The result of the read operation if successful, or undefined if there was not enough bits to complete the operation.
     */
    static tryRead(reader, options = {}) {
        let previouslyRetaining = reader.retainBuffers;
        let startOffset = reader.offset;
        reader.retainBuffers = true;
        try {
            let iterator = this.read(reader, options);
            let result = iterator.next();
            if (result.done === false) {
                // we need more bits, fail
                reader.offset = startOffset;
                return undefined;
            }
            return result.value;
        }
        catch (e) {
            reader.offset = startOffset;
            throw e;
        }
        finally {
            reader.retainBuffers = previouslyRetaining;
        }
    }
    /**
     * Try to read the bitstream using the given generator function synchronously, if there are not enough bits, abort
     * and return undefined.
     * @param reader The reader to read from
     * @returns A generator which when called will result in exactly one result. The result will either be a number
     *      (in which case 'done' is false) indicating that more bits were required to complete the read operation but
     *      they were unavailable on the given stream. Otherwise it will be an instance of the expected element type (in which
     *      case 'done' is true). The stream will be left in the state where the partial data was read. If you want to
     *      undo the read of the partial data, you will need to use retainBuffers = true, take note of the reader's offset
     *      before the operation, and set the offset of the reader back to that value after the failed read. Note that
     *      retainBuffers requires you to manage the saved buffers manually (see BitstreamReader.clean()).
     */
    static *read(reader, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        (_a = options.context) !== null && _a !== void 0 ? _a : (options.context = {});
        let constructorParams = (_d = (_b = options.params) !== null && _b !== void 0 ? _b : (_c = options.elementBeingVariated) === null || _c === void 0 ? void 0 : _c.savedConstructorParams) !== null && _d !== void 0 ? _d : [];
        let element = new this(...constructorParams);
        if (options.initializer) {
            options.initializer(element);
        }
        if ((_f = (_e = options.field) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.initializer) {
            options.field.options.initializer(element, options.parent);
        }
        element.savedConstructorParams = constructorParams;
        let allowExhaustion = (_g = options.allowExhaustion) !== null && _g !== void 0 ? _g : false;
        element.context = options.context;
        element.onParseStarted(options.elementBeingVariated);
        element.parent = options.parent;
        let parentStillReading = (_j = (_h = options.elementBeingVariated) === null || _h === void 0 ? void 0 : _h.isBeingRead) !== null && _j !== void 0 ? _j : false;
        element.isBeingRead = true;
        element.bitsRead = 0;
        if (options.elementBeingVariated) {
            element.bitsRead = options.elementBeingVariated.bitsRead;
            element.syntax.forEach(f => {
                var _a, _b;
                if (((_b = (_a = options.field) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.skip) && options.field.options.skip.includes(f.name))
                    return;
                if (options.skip && options.skip.includes(f.name))
                    return;
                if (options.elementBeingVariated.syntax.some(x => x.name === f.name) && options.elementBeingVariated.readFields.includes(f.name)) {
                    if (!f.options.isIgnored)
                        element[f.name] = options.elementBeingVariated[f.name];
                    element.readFields.push(f.name);
                }
            });
            options.elementBeingVariated.onVariationTo(element);
            element.onVariationFrom(options.elementBeingVariated);
            let g = element.readOwn(reader, { skip: (_l = (_k = options.field) === null || _k === void 0 ? void 0 : _k.options) === null || _l === void 0 ? void 0 : _l.skip });
            while (true) {
                let result = g.next();
                if (result.done === false) {
                    if (allowExhaustion)
                        return element;
                    let incompleteResult = result.value;
                    yield {
                        remaining: incompleteResult.remaining,
                        contextHint: () => element.summarizeElementOperation(`${this.name}.readVariant()`, incompleteResult.contextHint()),
                        optional: incompleteResult.optional
                    };
                }
                else {
                    element = result.value;
                    break;
                }
            }
        }
        else {
            let g = element.read(reader, { skip: [...((_m = options.skip) !== null && _m !== void 0 ? _m : []), ...((_q = (_p = (_o = options.field) === null || _o === void 0 ? void 0 : _o.options) === null || _p === void 0 ? void 0 : _p.skip) !== null && _q !== void 0 ? _q : [])] });
            while (true) {
                let result = g.next();
                if (result.done === false) {
                    if (allowExhaustion)
                        return element;
                    let incompleteResult = result.value;
                    yield {
                        remaining: incompleteResult.remaining,
                        contextHint: () => element.summarizeElementOperation(`${this.name}.read()`, incompleteResult.contextHint()),
                        optional: incompleteResult.optional
                    };
                }
                else {
                    element = result.value;
                    break;
                }
            }
        }
        element.isBeingRead = parentStillReading;
        // Perform tail variation: Only used when there is no @VariantMarker() within the element.
        // For marker variation, see readGroup()'s use of variate()
        if (!element.ownSyntax.some(x => x.options.isVariantMarker)) {
            let g = element.variate(reader, options.parent, options.field);
            while (true) {
                let result = g.next();
                if (result.done === false) {
                    if (allowExhaustion)
                        return element;
                    let incompleteResult = result.value;
                    yield {
                        remaining: incompleteResult.remaining,
                        contextHint: () => element.summarizeElementOperation(`tail-variation`, incompleteResult.contextHint()),
                        optional: incompleteResult.optional
                    };
                }
                else {
                    element = result.value;
                    break;
                }
            }
        }
        delete element.savedConstructorParams;
        if (!(options === null || options === void 0 ? void 0 : options.elementBeingVariated))
            element.onParseFinished();
        return element;
    }
    summarizeElementField(field, innerContext) {
        return `${innerContext}\n[readField()] ${this.constructor.name}#${String(field.name)}`;
    }
    summarizeElementOperation(operation, innerContext) {
        return `${innerContext}\n[${operation}] ${this.constructor.name}`;
    }
}
_BitstreamElement_parent = new WeakMap(), _BitstreamElement_readFields = new WeakMap(), _BitstreamElement_isBeingRead = new WeakMap(), _BitstreamElement_fieldBeingComputed = new WeakMap(), _BitstreamElement_fieldBeingComputedIntrospectable = new WeakMap();
//# sourceMappingURL=element.js.map