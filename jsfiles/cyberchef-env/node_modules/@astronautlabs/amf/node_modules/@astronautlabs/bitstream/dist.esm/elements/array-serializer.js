import { resolveLength } from "./resolve-length";
import { StructureSerializer } from "./structure-serializer";
import { summarizeField } from "./utils";
/**
 * Serializes arrays to/from bitstreams
 */
export class ArraySerializer {
    *read(reader, type, parent, field) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        let count = 0;
        let elements = [];
        if ((_b = (_a = field === null || field === void 0 ? void 0 : field.options) === null || _a === void 0 ? void 0 : _a.array) === null || _b === void 0 ? void 0 : _b.countFieldLength) {
            if (!reader.isAvailable(field.options.array.countFieldLength))
                yield { remaining: field.options.array.countFieldLength, contextHint: () => summarizeField(field) };
            count = reader.readSync(field.options.array.countFieldLength);
        }
        else if ((_d = (_c = field === null || field === void 0 ? void 0 : field.options) === null || _c === void 0 ? void 0 : _c.array) === null || _d === void 0 ? void 0 : _d.count) {
            count = resolveLength(field.options.array.count, parent, field);
        }
        else if (field === null || field === void 0 ? void 0 : field.length) {
            count = resolveLength(field === null || field === void 0 ? void 0 : field.length, parent, field);
        }
        if (parent) {
            parent.readFields.push(field.name);
            parent[field.name] = [];
        }
        if (((_f = (_e = field === null || field === void 0 ? void 0 : field.options) === null || _e === void 0 ? void 0 : _e.array) === null || _f === void 0 ? void 0 : _f.type) === Number) {
            // Array of numbers. Useful when the array holds a single number field, but the 
            // bit length of the element fields is not 8 (where you would probably use a single `Buffer` field instead).
            // For instance, in somes IETF RFCs 10 bit words are used instead of 8 bit words (ie bytes).
            let elementLength = field.options.array.elementLength;
            let format = (_j = (_h = (_g = field === null || field === void 0 ? void 0 : field.options) === null || _g === void 0 ? void 0 : _g.number) === null || _h === void 0 ? void 0 : _h.format) !== null && _j !== void 0 ? _j : 'unsigned';
            let readNumber = () => {
                if (format === 'signed')
                    elements.push(reader.readSignedSync(elementLength));
                else if (format === 'float')
                    elements.push(reader.readFloatSync(elementLength));
                else if (format === 'unsigned')
                    elements.push(reader.readSync(elementLength));
                else
                    throw new Error(`Unsupported number format '${format}'`);
            };
            if ((_l = (_k = field === null || field === void 0 ? void 0 : field.options) === null || _k === void 0 ? void 0 : _k.array) === null || _l === void 0 ? void 0 : _l.hasMore) {
                do {
                    let continued;
                    try {
                        parent.runWithFieldBeingComputed(field, () => continued = field.options.array.hasMore(elements, parent, parent.parent), true);
                    }
                    catch (e) {
                        throw new Error(`${(parent === null || parent === void 0 ? void 0 : parent.constructor.name) || '<none>'}#${String((field === null || field === void 0 ? void 0 : field.name) || '<none>')} Failed to determine if array has more items via 'hasMore' discriminant: ${e.message}`);
                    }
                    if (!continued)
                        break;
                    if (!reader.isAvailable(elementLength))
                        yield { remaining: elementLength, contextHint: () => summarizeField(field) };
                    readNumber();
                } while (true);
            }
            else {
                for (let i = 0; i < count; ++i) {
                    if (!reader.isAvailable(elementLength))
                        yield { remaining: elementLength, contextHint: () => summarizeField(field) };
                    readNumber();
                }
            }
        }
        else {
            if (field.options.array.hasMore) {
                let i = 0;
                do {
                    let continued;
                    try {
                        parent.runWithFieldBeingComputed(field, () => continued = field.options.array.hasMore(elements, parent, parent.parent), true);
                    }
                    catch (e) {
                        throw new Error(`${(parent === null || parent === void 0 ? void 0 : parent.constructor.name) || '<none>'}#${String((field === null || field === void 0 ? void 0 : field.name) || '<none>')} Failed to determine if array has more items via 'hasMore' discriminant: ${e.message}`);
                    }
                    if (!continued)
                        break;
                    let element;
                    let serializer = new StructureSerializer();
                    let gen = serializer.read(reader, field.options.array.type, parent, field);
                    while (true) {
                        let result = gen.next();
                        if (result.done === false) {
                            yield result.value;
                        }
                        else {
                            element = result.value;
                            break;
                        }
                    }
                    elements.push(element);
                    parent[field.name].push(element);
                } while (true);
            }
            else {
                for (let i = 0; i < count; ++i) {
                    let element;
                    let serializer = new StructureSerializer();
                    let g = serializer.read(reader, field.options.array.type, parent, field);
                    while (true) {
                        let result = g.next();
                        if (result.done === false) {
                            yield result.value;
                        }
                        else {
                            element = result.value;
                            break;
                        }
                    }
                    elements.push(element);
                    parent[field.name].push(element);
                }
            }
        }
        return elements;
    }
    write(writer, type, parent, field, value) {
        var _a, _b, _c, _d, _e;
        if (!value) {
            throw new Error(`${(parent === null || parent === void 0 ? void 0 : parent.constructor.name) || '<none>'}#${String(field === null || field === void 0 ? void 0 : field.name) || '<none>'}: Cannot serialize a null array!`);
        }
        let length = value.length;
        if (field.options.array.countFieldLength) {
            let countFieldLength = field.options.array.countFieldLength;
            if (length >= Math.pow(2, countFieldLength)) {
                length = Math.pow(2, countFieldLength) - 1;
            }
            writer.write(field.options.array.countFieldLength, value.length);
        }
        else if (field.options.array.count) {
            try {
                length = resolveLength(field.options.array.count, parent, field);
            }
            catch (e) {
                throw new Error(`Failed to resolve length for array via 'count': ${e.message}`);
            }
            if (length > value.length) {
                throw new Error(`${field.containingType.name}#${String(field.name)}: `
                    + `Array field's count determinant specified ${length} elements should be written `
                    + `but array only contains ${value.length} elements. `
                    + `Ensure that the value of the count determinant is compatible with the number of elements in `
                    + `the provided array.`);
            }
        }
        for (let i = 0; i < length; ++i) {
            if (((_b = (_a = field === null || field === void 0 ? void 0 : field.options) === null || _a === void 0 ? void 0 : _a.array) === null || _b === void 0 ? void 0 : _b.type) === Number) {
                let type = (_e = (_d = (_c = field.options) === null || _c === void 0 ? void 0 : _c.number) === null || _d === void 0 ? void 0 : _d.format) !== null && _e !== void 0 ? _e : 'unsigned';
                if (type === 'unsigned')
                    writer.write(field.options.array.elementLength, value[i]);
                else if (type === 'signed')
                    writer.writeSigned(field.options.array.elementLength, value[i]);
                else if (type === 'float')
                    writer.writeFloat(field.options.array.elementLength, value[i]);
            }
            else {
                value[i].write(writer, { context: parent === null || parent === void 0 ? void 0 : parent.context });
            }
        }
    }
}
//# sourceMappingURL=array-serializer.js.map