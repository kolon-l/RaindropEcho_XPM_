import { Writable } from "../common";
/**
 * A class for writing numbers of varying bitlengths to a Node.js Writable.
 * All data is written in big-endian (network) byte order.
 */
export declare class BitstreamWriter {
    stream: Writable;
    readonly bufferSize: number;
    /**
     * Create a new writer
     * @param stream The writable stream to write to
     * @param bufferSize The number of bytes to buffer before flushing onto the writable
     */
    constructor(stream: Writable, bufferSize?: number);
    private pendingByte;
    private pendingBits;
    private buffer;
    private bufferedBytes;
    private _offset;
    /**
     * How many bits have been written via this writer in total
     */
    get offset(): number;
    /**
     * How many bits into the current byte is the write cursor.
     * If this value is zero, then we are currently byte-aligned.
     * A value of 7 means we are 1 bit away from the byte boundary.
     */
    get byteOffset(): number;
    /**
     * Finish the current byte (assuming zeros for the remaining bits, if necessary)
     * and flushes the output.
     */
    end(): void;
    /**
     * Reset the bit offset of this writer back to zero.
     */
    reset(): void;
    private finishByte;
    flush(): void;
    private textEncoder;
    /**
     * Decode a string into a set of bytes and write it to the bitstream, bounding the string
     * by the given number of bytes, optionally using the given encoding (or UTF-8 if not specified).
     * @param byteCount The number of bytes to bound the output to
     * @param value The string to decode and write
     * @param encoding The encoding to use when writing the string. Defaults to utf-8
     */
    writeString(byteCount: number, value: string, encoding?: string): void;
    /**
     * Write the given buffer to the bitstream. This is done by treating each byte as an 8-bit write.
     * Note that the bitstream does not need to be byte-aligned to call this method, meaning you can write
     * a set of bytes at a non=zero bit offset if you wish.
     * @param buffer The buffer to write
     * @deprecated Use writeBytes() instead
     */
    writeBuffer(buffer: Uint8Array): void;
    /**
     * Write the given buffer to the bitstream. This is done by treating each byte as an 8-bit write.
     * Note that the bitstream does not need to be byte-aligned to call this method, meaning you can write
     * a set of bytes at a non=zero bit offset if you wish.
     * @param chunk The buffer to write
     */
    writeBytes(chunk: Uint8Array, offset?: number, length?: number): void;
    private min;
    /**
     * Write the given number to the bitstream with the given bitlength. If the number is too large for the
     * number of bits specified, the lower-order bits are written and the higher-order bits are ignored.
     * @param length The number of bits to write
     * @param value The number to write
     */
    write(length: number, value: number): void;
    writeSigned(length: number, value: number): void;
    writeFloat(length: number, value: number): void;
}
/**
 * A specialized BitstreamWriter which does not write to a stream, but instead measures the number of
 * bits written by the caller. This is used to implement measurement in BitstreamElement
 */
export declare class BitstreamMeasurer extends BitstreamWriter {
    constructor();
    bitLength: number;
    writeString(byteCount: number, value: string, encoding?: string): void;
    writeBuffer(buffer: Uint8Array): void;
    write(length: number, value: number): void;
}
