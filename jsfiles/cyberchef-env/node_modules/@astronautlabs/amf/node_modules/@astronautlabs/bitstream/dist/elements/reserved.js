"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reserved = void 0;
const resolve_length_1 = require("./resolve-length");
const field_1 = require("./field");
/**
 * Used to mark a specific field as reserved. The value in this field will be read, but will not be
 * copied into the BitsreamElement, and when writing the value will always be all high bits. For a
 * version using low bits, see `@ReservedLow`.
 *
 * Oftentimes it is desirable to avoid naming reserved fields, especially in formats with lots of small reservation
 * sections. Unfortunately Typescript doesn't provide a good way to do this (computed symbol names cannot be generated by
 * function calls).
 *
 * However, be assured that if you reuse a reserved field name in a subclass (which is not itself an error in Typescript),
 * the resulting bitstream representation will still be correct. There are two reasons for this:
 * - Every new field declaration is a new syntax field, even if the field exists in a superclass.
 * - `@Reserved()` specifically replaces the name you specify with an anonymous symbol
 *
 * @param length The bitlength determinant
 * @param options Options related to this reserved field
 */
function Reserved(length, options = {}) {
    return (target, fieldName) => {
        fieldName = Symbol(`[reserved: ${typeof length === 'number' ? `${length} bits` : `dynamic`}]`);
        Reflect.defineMetadata('design:type', Number, target, fieldName);
        return (0, field_1.Field)(length, Object.assign(Object.assign({}, options), { isIgnored: true, writtenValue: (instance, field) => {
                if (field.type === Number) {
                    let currentLength = (0, resolve_length_1.resolveLength)(field.length, instance, field);
                    return Math.pow(2, currentLength) - 1;
                }
            } }))(target, fieldName);
    };
}
exports.Reserved = Reserved;
//# sourceMappingURL=reserved.js.map