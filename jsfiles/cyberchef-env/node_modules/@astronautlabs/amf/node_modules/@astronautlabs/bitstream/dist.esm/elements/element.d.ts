import { BitstreamReader, BitstreamWriter } from "../bitstream";
import { Constructor, IncompleteReadResult } from "../common";
import { FieldDefinition } from "./field-definition";
import { VariantDefinition } from "./variant-definition";
/**
 * A reference to a field. Can be a string/symbol or a type-safe function
 * which exemplifies the field.
 */
export type FieldRef<T> = string | symbol | ((exemplar: {
    [P in keyof T]: any;
}) => any);
/**
 * Specify options when serializing a value
 */
export interface CommonOptions {
    /**
     * Set of fields to skip while writing
     */
    skip?: (string | symbol)[];
    context?: any;
}
/**
 * @deprecated
 */
export interface SerializeOptions extends CommonOptions {
}
/**
 * These options are available on BitstreamElement#read*() operations (ie those which apply to an existing instance).
 */
export interface ReadOptions<T = BitstreamElement> extends CommonOptions {
    parent?: BitstreamElement;
    field?: FieldDefinition;
    variator?: () => Promise<T>;
}
/**
 * These options are available on BitstreamElement.read*() operations (ie those which are static)
 */
export interface StaticReadOptions<T = BitstreamElement> extends ReadOptions<T> {
    /**
     * When true, the operation will complete as soon as there are not enough bits. This is not intended
     * to be used on data streamed in, but rather for situations where all the data for the entire read
     * operation is already available (such as BitstreamElement.deserialize()).
     *
     * If you are reading from a buffer using BitstreamElement.read() directly, you might consider
     * using deserialize() instead.
     */
    allowExhaustion?: boolean;
    elementBeingVariated?: BitstreamElement;
    params?: any[];
    /**
     * Provide a function which will be invoked passing the new instance being created.
     * Useful for customizing the setup of an object before it is otherwise parsed.
     * This is run after constructing the object but before parsing any fields.
     */
    initializer?: (instance: T) => void;
}
/**
 * These options are available when using Element.deserialize().
 */
export interface DeserializeOptions<T = BitstreamElement> extends StaticReadOptions<T> {
    /**
     * When true, the deserialize() operation will succeed even if there are not enough bits
     * to satisfy the fields of the bitstream element. This is useful if there are optional trailing
     * fields where you are expected to stop reading (but continue without error) if there is no more
     * data left.
     */
    allowExhaustion?: boolean;
}
/**
 * BitstreamElement is a base class which can be extended to produce "structures" that can be
 * read from and written to a bitstream. It allows you to specify fields along with their type
 * and bitlength information declaratively, allowing BitstreamElement itself to handle the actual
 * serialization/deserialization in the context of a passed BitstreamReader/BitstreamWriter.
 */
export declare class BitstreamElement {
    #private;
    /**
     * When serializing/deserializing a BitstreamElement, this contains an anonymous object that is shared by the
     * top-level element and all sub-elements that are involved in the operation. The object is set to this property
     * at the earliest possible moment- for serialization this is just prior to the onSerializeStarted() event,
     * for deserialization this is just after the instance is created.
     */
    context: any;
    /**
     * Number of total bits read from bitstream readers so far while parsing this element.
     * Each read operation done via the read*() methods accumulates this counter. This can be
     * a useful alternative to measure() when implementing "tail" buffers for extensible element
     * types when there are multiple valid ways to encode data which has been read,
     * ie the way you read it might not be the same as when you write it.
     *
     * The alternative (measure()) requires that the decoding and encoding of a specific bitstream element
     * must be binary-compatible (ie that there is exactly one correct way to encode the data).
     */
    bitsRead: number;
    /**
     * The constructor parameters passed when constructing this element.
     * These must be saved for use during variation, should it be needed.
     * The values will be cleared out after parsing is completed.
     */
    savedConstructorParams: any[];
    /**
     * Called when this object is created as part of an element parsing operation.
     * - For unvariated elements this is called before parsing begins.
     * - For variated elements this is called before the original element's fields are copied into this instance.
     *   The instance being variated is passed as 'variatingFrom' in this case.
     *
     * In either case, no fields have been populated within the instance before the lifecycle event is invoked.
     * To observe the values copied in when this object is the result of variation, see onVariationFrom().
     */
    onParseStarted(variatingFrom?: BitstreamElement): void;
    /**
     * Called when this object has completed parsing including all variation operations.
     *
     * Note that onParseFinished() may not be invoked if the bitstream is exhausted before
     * parsing is finished or if this instance is replaced via variation. To observe this process, use
     * onVariationTo/onVariationFrom. The final variation is the only one that has onParseFinished() invoked.
     */
    onParseFinished(): void;
    /**
     * Called when this object is undergoing variation. The 'replacement' parameter contains the newly variated
     * object. No further lifecycle events will occur for this instance, and all future lifecycle events occur on
     * the replacement object.
     *
     * @param replacement
     */
    onVariationTo(replacement: BitstreamElement): void;
    /**
     * Called when this object is the result of a variation operation. The 'source' parameter contains the original
     * object. At this point all fields of the variation source have been copied into the new variant object.
     * @param source
     */
    onVariationFrom(source: BitstreamElement): void;
    /**
     * Called when this object is about to be serialized to a BitstreamWriter.
     */
    onSerializeStarted(): void;
    /**
     * Called when this object has been completely serialized to a BitstreamWriter.
     */
    onSerializeFinished(): void;
    /**
     * Retrieve the "syntax" of this element, which is the list of fields defined on the element
     * in order of appearance within the bitstream.
     */
    static get syntax(): FieldDefinition[];
    determineVariantType(parent?: BitstreamElement, variants?: (Function | VariantDefinition)[]): any;
    /**
     * Create a copy of this element instance
     * @returns A new copy of this element
     */
    clone(): this;
    /**
     * Retrieve the field definition of a field as specified by the given field reference
     * @param ref The field being referenced
     * @returns The field definition
     */
    selectField(ref: FieldRef<this>): FieldDefinition<BitstreamElement, any>;
    /**
     * The size of the write buffer when using the serialize() method. This is set to 1KB by default, but may need to
     * be tweaked for large objects.
     */
    serializeBufferSize: number;
    /**
     * Serialize all fields or a subset of fields into a buffer.
     * @param fromRef The first field that should be serialized. If not specified, serialization begins at the start of
     *                  the element
     * @param toRef The last field that should be serialized. If not specified, serialization continues until the end of
     *                  the element
     * @param autoPad When true and the bitsize of a field is not a multiple of 8, the final byte will
     *                  contain zeros up to the next byte. When false (default), serialize() will throw
     *                  if the size is not a multiple of 8.
     */
    serialize(fromRef?: FieldRef<this>, toRef?: FieldRef<this>, autoPad?: boolean): Uint8Array;
    /**
     * Measure the number of bits starting from the first field and continuing through the structure until the last
     * field.
     * @param fromRef The field to start measuring from (including the specified field). When not specified, measurement
     *                  starts from the first field
     * @param toRef The field to stop measuring at (including the specified field). When not specified, measurement
     *                  ends at the last field
     * @returns The number of bits occupied by the range of fields
     */
    measure(fromRef?: FieldRef<this>, toRef?: FieldRef<this>): number;
    /**
     * Measure from the beginning of the element to the given field
     * @param toRef The field to stop measuring at (including the specified field)
     * @returns The number of bits occupied by the set of fields
     */
    measureTo(toRef?: FieldRef<this>): number;
    /**
     * Measure from the given field to the end of the element
     * @param fromRef The field to start measuing at (including the specified field)
     * @returns The number of bits occupied by the set of fields
     */
    measureFrom(fromRef?: FieldRef<this>): number;
    /**
     * Measure the size of a specific field
     * @param ref The field to measure
     * @returns The number of bits occupied by the field
     */
    measureField(ref?: FieldRef<this>): number;
    /**
     * Check that this instance is one of a set of given subtypes. If it is,
     * this instance is returned with the more specific type.
     * If it is not, an error is thrown.
     *
     * @param typeChecks One or more subclasses to check
     * @returns This instance, but casted to the desired type
     */
    as<T>(...typeChecks: Constructor<T>[]): T;
    /**
     * Check that this instance is one of a set of given subtypes.
     * @param typeChecks
     * @returns
     */
    is<T>(...typeChecks: Constructor<T>[]): this is T;
    /**
     * Retrieve the set of defined variants for this element class
     */
    static get variants(): VariantDefinition[];
    /**
     * Retrieve the set of variants for this specific class, excluding those
     * of its superclasses
     */
    static ownVariants: VariantDefinition[];
    /**
     * Retrieve the syntax defined for this specific class, excluding the syntax
     * defined by its superclasses
     */
    static get ownSyntax(): FieldDefinition[];
    static set ownSyntax(value: FieldDefinition[]);
    /**
     * Retrieve the element which contains this element, if any
     */
    get parent(): BitstreamElement;
    /**
     * Set the parent element of this element
     */
    set parent(value: BitstreamElement);
    /**
     * True when this element is currently being read, false otherwise
     */
    get isBeingRead(): boolean;
    /**
     * Set whether this element is currently being read
     */
    set isBeingRead(value: boolean);
    /**
     * Retrieve the set of field names which has been read so far
     */
    get readFields(): (string | symbol)[];
    /**
     * Determine if the field currently being computed is introspectable,
     * meaning that the bits it has read so far will be considered during measurement,
     * even though it possibly has not finished reading all bits it will read yet
     * @returns
     */
    getFieldBeingComputedIntrospectable(): boolean;
    /**
     * Get the definition of the field currently being computed, if any.
     * @returns
     */
    getFieldBeingComputed(): FieldDefinition<BitstreamElement, any>;
    /**
     * Convert this element to a JSON-compatible representation which contains
     * only the fields defined on the element (aka its "syntax")
     */
    toJSON(): {};
    /**
     * Run the given callback while in a state where the given field is considered to be the one "being computed",
     * which is primarily used to enable the current size of arrays as they are read in cases where the count of
     * items in the array is dependent on the overall bitlength of the previous elements that have been read. See
     * the `hasMore` option of ArrayOptions
     *
     * @param field The field being computed
     * @param callback The function to run
     * @param introspectable When true, the computed field is marked as introspectable
     */
    runWithFieldBeingComputed<T>(field: FieldDefinition, callback: () => T, introspectable?: boolean): T;
    /**
     * Get the "syntax" of this element instance; this is the set of fields that compose the element, in order.
     */
    get syntax(): FieldDefinition[];
    /**
     * Get the "syntax" of this element instance excluding syntax defined by its superclasses; this is the
     * set of fields that compose the elemnet, in order.
     */
    get ownSyntax(): FieldDefinition[];
    private leftPad;
    private rightPad;
    private zeroPad;
    private isPresent;
    /**
     * Read a specific group of fields from the bitstream and serialize their values into this instance. This is called
     * by BitstreamElement for you, but can be used when overriding the default read behavior.
     * @param bitstream The bitstream reader to read from
     * @param name The name of the group to read. Some special values are accepted: '*' means all fields, '$*' means all
     *              fields defined directly on this class (excluding its superclasses). Other group specifiers starting
     *              with '$' match fields defined directly on this class which are part of the specified group (for
     *              instance '$foo' matches directly defined fields in the 'foo' group). Otherwise, the string is
     *              matched directly against the 'group' option of all fields.
     * @param variator A function which implements variation of this instance in the case where a `@VariantMarker` is
     *              encountered. The function should determine an appropriate variant and return it; when it does so,
     *              the group will continue to be read after the marker, but the results of reading the field will be
     *              applied to the returned instance instead of this instance
     * @param options Serialization options that modify how the group is read. Most notably this allows you to skip
     *              specific fields.
     * @returns A generator. When the read is complete (done=true), the result will be the current instance,
     *              unless the instance was variated into a subclass, in which case it will be the
     *              variated subclass instance. Because this process can occur, it is important to observe the result
     *              of this function. If the read buffer becomes exhausted, an IncompleteReadResult will be returned.
     */
    protected readGroup(bitstream: BitstreamReader, name: string, options?: ReadOptions<this>): Generator<IncompleteReadResult, this>;
    /**
     * Write a group of fields to the given bitstream writer. This is used by BitstreamElement internally, but it can
     * be called directly when overriding the default write behavior in a subclass, if desired.
     * @param bitstream The bitstream writer to write the fields to
     * @param name The name of the group to write.
     * @param options Options that modify how the group is written. Most notably this allows you to skip specific
     *                  fields.
     */
    protected writeGroup(bitstream: BitstreamWriter, name: string, options?: CommonOptions): void;
    /**
     * Read this element from the given bitstream reader, applying the resulting values into this instance.
     * @param bitstream The reader to read from
     * @param variator A function which implements variation for this instance. The function should determine an
     *                  appropriate variant instance and return it; from there on out the rest of the fields read will
     *                  be applied to that instance instead of this instance.
     * @param options Options which modify how the element is read. Most notably this lets you skip specific fields
     * @returns The current instance, unless it was variated into a subclass instance, in which case it will be the
     *                  variated subclass instance. Thus it is important to observe the result of this method.
     */
    read(bitstream: BitstreamReader, options?: CommonOptions): Generator<IncompleteReadResult, this, unknown>;
    /**
     * Read just the fields that are part of this specific subclass, ignoring the fields that are defined on superclasses.
     * This is used by BitstreamElement during variation, and is equivalent to readGroup(bitstream, '$*', variator, options)
     * @param bitstream The reader to read from
     * @param variator A function which implements variation for this instance. The function should determine an
     *                  appropriate variant instance and return it; from there on out the rest of the fields read will
     *                  be applied to that instance instead of this instance.
     * @param options Options which modify how the element is read. Most notably this lets you skip specific fields
     * @returns A generator which will yield only one result. If the generator completes (done=true), then the result
     *          will be `this` the current instance, unless it was variated into a subclass instance, in which case
     *          it will be the variated subclass instance. Thus it is important to observe the result of this method.
     *          If the read buffer becomes exhausted, the result will be an IncompleteReadResult.
     */
    readOwn(bitstream: BitstreamReader, options?: CommonOptions): Generator<{
        remaining: number;
        contextHint: () => string;
        optional: boolean;
    }, this, unknown>;
    /**
     * Apply variation rules to this element. If one is found, the new variated instance is returned, otherwise
     * the current instance is returned.
     *
     * @param reader The reader to read from
     * @param parent The parent element of this element
     * @param field The Bitstream field that this element is being parsed for when this is a subelement of a larger
     *     parse operation.
     * @returns
     */
    variate(reader: BitstreamReader, parent?: BitstreamElement, field?: FieldDefinition): Generator<IncompleteReadResult, this>;
    /**
     * Create a new instance of this BitstreamElement subclass by reading the necessary fields from the given
     * BitstreamReader.
     * @param this
     * @param reader The reader to read from
     * @param parent Specify a parent instance which the new instance is found within
     * @returns
     */
    static readBlocking<T extends typeof BitstreamElement>(this: T, reader: BitstreamReader, options?: StaticReadOptions): Promise<InstanceType<T>>;
    /**
     * Deserialize an instance of this class from the given
     * data buffer. Will consider available variants, so the
     * result could be a subclass.
     * @param data
     * @returns
     */
    static deserialize<T extends typeof BitstreamElement>(this: T, data: Uint8Array, options?: DeserializeOptions): InstanceType<T>;
    /**
     * Write this instance to the given writer
     * @param bitstream The writer to write to
     * @param options Options which modify how the element is written. Most notably this lets you skip specific fields
     */
    write(bitstream: BitstreamWriter, options?: CommonOptions): void;
    /**
     * Apply the given properties to this object and return ourself.
     * @param this
     * @param changes The changes to apply
     */
    with<T>(this: T, changes: Partial<T>): T;
    /**
     * Perform a synchronous read operation on the given reader with the given generator. If there are not enough bits available
     * to complete the operation, this method will throw an exception.
     *
     * @param reader
     * @param generator
     * @returns
     */
    static readSync<T extends typeof BitstreamElement>(this: T, reader: BitstreamReader, options?: StaticReadOptions): InstanceType<T>;
    /**
     * Try to read the bitstream using the given generator function synchronously, if there are not enough bits, abort
     * and return undefined.
     * @param reader The reader to read from
     * @returns The result of the read operation if successful, or undefined if there was not enough bits to complete the operation.
     */
    static tryRead<T extends typeof BitstreamElement>(this: T, reader: BitstreamReader, options?: StaticReadOptions): InstanceType<T>;
    /**
     * Try to read the bitstream using the given generator function synchronously, if there are not enough bits, abort
     * and return undefined.
     * @param reader The reader to read from
     * @returns A generator which when called will result in exactly one result. The result will either be a number
     *      (in which case 'done' is false) indicating that more bits were required to complete the read operation but
     *      they were unavailable on the given stream. Otherwise it will be an instance of the expected element type (in which
     *      case 'done' is true). The stream will be left in the state where the partial data was read. If you want to
     *      undo the read of the partial data, you will need to use retainBuffers = true, take note of the reader's offset
     *      before the operation, and set the offset of the reader back to that value after the failed read. Note that
     *      retainBuffers requires you to manage the saved buffers manually (see BitstreamReader.clean()).
     */
    static read<T extends typeof BitstreamElement>(this: T, reader: BitstreamReader, options?: StaticReadOptions): Generator<{
        remaining: number;
        contextHint: () => string;
        optional: boolean;
    }, InstanceType<T>, unknown>;
    protected summarizeElementField(field: FieldDefinition, innerContext: string): string;
    protected summarizeElementOperation(operation: string, innerContext: string): string;
}
